/*
 * Copyright 2014 Alessandro Falappa <alex.falappa@gmail.com>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package gui.panels.geo;

import gov.nasa.worldwind.geom.LatLon;
import java.awt.geom.Point2D;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.Locale;
import javax.swing.JSpinner;
import main.App;

/**
 *
 * @author Alessandro Falappa <alex.falappa@gmail.com>
 */
public class CirclePanel extends javax.swing.JPanel {

    public CirclePanel() {
        initComponents();
        // set spinners locale to english (to get point as decimal separator)
        DecimalFormatSymbols decimalFormatSymbols = new DecimalFormatSymbols(Locale.ENGLISH);
        ((JSpinner.NumberEditor) spCenterLat.getEditor()).getFormat().setDecimalFormatSymbols(decimalFormatSymbols);
        ((JSpinner.NumberEditor) spCenterLon.getEditor()).getFormat().setDecimalFormatSymbols(decimalFormatSymbols);
        ((JSpinner.NumberEditor) spRadius.getEditor()).getFormat().setDecimalFormatSymbols(decimalFormatSymbols);
    }

    @Override
    public void setEnabled(boolean enabled) {
        lCenterLat.setEnabled(enabled);
        spCenterLat.setEnabled(enabled);
        lCenterLon.setEnabled(enabled);
        spCenterLon.setEnabled(enabled);
        lRadius.setEnabled(enabled);
        spRadius.setEnabled(enabled);
        lUom1.setEnabled(enabled);
        lUom2.setEnabled(enabled);
        lUom3.setEnabled(enabled);
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this
     * method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lCenterLat = new javax.swing.JLabel();
        lCenterLon = new javax.swing.JLabel();
        lRadius = new javax.swing.JLabel();
        spCenterLat = new javax.swing.JSpinner();
        spCenterLon = new javax.swing.JSpinner();
        spRadius = new javax.swing.JSpinner();
        bGraphSel = new javax.swing.JButton();
        bDraw = new javax.swing.JButton();
        lUom1 = new javax.swing.JLabel();
        lUom2 = new javax.swing.JLabel();
        lUom3 = new javax.swing.JLabel();
        bDrawPoly = new javax.swing.JButton();
        lCorners = new javax.swing.JLabel();

        lCenterLat.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        lCenterLat.setText("Center Lat");

        lCenterLon.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        lCenterLon.setText("Center Lon");

        lRadius.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        lRadius.setText("Radius");

        spCenterLat.setModel(new javax.swing.SpinnerNumberModel(0.0d, -90.0d, 90.0d, 1.0d));

        spCenterLon.setModel(new javax.swing.SpinnerNumberModel(0.0d, -180.0d, 180.0d, 1.0d));

        spRadius.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(0.0d), null, null, Double.valueOf(500.0d)));

        bGraphSel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/gui/images_16x16/glyphicons_095_vector_path_circle.png"))); // NOI18N
        bGraphSel.setText("Graphical Selection");
        bGraphSel.setEnabled(false);
        bGraphSel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bGraphSelActionPerformed(evt);
            }
        });

        bDraw.setText("Draw");
        bDraw.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bDrawActionPerformed(evt);
            }
        });

        lUom1.setText("mt.");

        lUom2.setText("deg.");

        lUom3.setText("deg.");

        bDrawPoly.setText("Draw polygonal approx.");
        bDrawPoly.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bDrawPolyActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(bDrawPoly)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lCorners, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(lCenterLat)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spCenterLat, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lUom3))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(lCenterLon)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spCenterLon, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lUom2))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(lRadius)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spRadius, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lUom1)))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(bGraphSel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(bDraw)))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {lCenterLat, lCenterLon, lRadius});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lCenterLat)
                    .addComponent(spCenterLat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lUom3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lCenterLon)
                    .addComponent(spCenterLon, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lUom2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lRadius)
                    .addComponent(spRadius, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lUom1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lCorners, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(bDrawPoly, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(bGraphSel)
                    .addComponent(bDraw))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void bDrawActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bDrawActionPerformed
        LatLon center = LatLon.fromDegrees((double) spCenterLat.getValue(), (double) spCenterLon.getValue());
        App.frame.aois.setSurfCircle(center, (double) spRadius.getValue());
        App.frame.wwCanvas.redraw();
    }//GEN-LAST:event_bDrawActionPerformed

    private void bGraphSelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bGraphSelActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_bGraphSelActionPerformed

    private void bDrawPolyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bDrawPolyActionPerformed
        App.frame.aois.setSurfPoly(circleToPolygon((double) spCenterLon.getValue(), (double) spCenterLat.getValue(), (double) spRadius.getValue()));
        App.frame.wwCanvas.redraw();
    }//GEN-LAST:event_bDrawPolyActionPerformed

    /**
     * Approximate a circle of the given center and radius with a 40 sided regular polygon.
     * <p>
     * Returned geometry is in WKT string format. Calculations are performed on the WGS84 geodetic spheroid.
     * <p>
     * @param lon    Center longitude
     * @param lat    Center latitude
     * @param radius Radius, in meters
     * @return The polygon in WKT string
     */
    public ArrayList<LatLon> circleToPolygon(double lon, double lat, double radius) {
        int n_corners = (int) Math.round(2 * Math.PI * radius / 10000);
        int n_cornersRound = 0;
        if (n_corners > 800) {
            n_cornersRound = 360;
        }
        if (n_corners <= 800 && n_corners > 100) {
            n_cornersRound = 180;
        } else if (n_corners <= 100 && n_corners > 20) {
            n_cornersRound = 90;
        } else if (n_corners <= 20) {
            n_cornersRound = 36;
        }
        lCorners.setText(String.format("%d corners", n_cornersRound));
        ArrayList<LatLon> output = new ArrayList<>(n_cornersRound + 1);
        Point2D.Double center = new Point2D.Double(lon, lat);
        // add the first point (0° bearing or heading north)
        Point2D.Double point0 = directVincenty(center, 0, radius);
        // repeat calculation increasing bearing by 360° / n_corners
        output.add(LatLon.fromDegrees(point0.y, point0.x));
        int alfa = Math.round(360 / n_cornersRound);
        int angleAlfa = alfa;
        for (int countFor = 2; angleAlfa < 360; countFor++) {
            Point2D.Double point = directVincenty(center, angleAlfa, radius);
            output.add(LatLon.fromDegrees(point.y, point.x));
            angleAlfa = alfa * countFor;
        }
        // repeat the first point to close polygon
        output.add(LatLon.fromDegrees(point0.y, point0.x));
        return output;
    }

    /**
     * Calculate a destination lat/long point given start point lat/long (in decimal degrees), bearing angle (decimal degrees) and a
     * distance (meters).
     * <p>
     * The code employs the Vincenty direct formula from T.Vincenty, "Direct and Inverse Solutions of Geodesics on the Ellipsoid with
     * application of nested equations", Survey Review, vol XXII no 176, 1975 http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf
     * <p>
     * See http://www.movable-type.co.uk/scripts/latlong-vincenty-direct.html for explanation and sample web application.
     * <p>
     * @param point
     * @param brng
     * @param distance
     * @return
     */
    public Point2D.Double directVincenty(Point2D.Double point, double brng, double distance) {
        // WGS-84 ellipsoid parameters
        double a = 6378137, b = 6356752.3142, f = 1 / 298.257223563;
        double s = distance;
        double alpha1 = brng * Math.PI / 180;
        double sinAlpha1 = Math.sin(alpha1);
        double cosAlpha1 = Math.cos(alpha1);
        double tanU1 = (1 - f) * Math.tan(point.y * Math.PI / 180);
        double cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1
                * cosU1;
        double sigma1 = Math.atan2(tanU1, cosAlpha1);
        double sinAlpha = cosU1 * sinAlpha1;
        double cosSqAlpha = 1 - sinAlpha * sinAlpha;
        double uSq = cosSqAlpha * (a * a - b * b) / (b * b);
        double A = 1 + uSq / 16384
                * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
        double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
        double cos2SigmaM = Double.NaN;
        double sinSigma = Double.NaN;
        double cosSigma = Double.NaN;
        double sigma = s / (b * A), sigmaP = 2 * Math.PI;
        while (Math.abs(sigma - sigmaP) > 1e-12) {
            cos2SigmaM = Math.cos(2 * sigma1 + sigma);
            sinSigma = Math.sin(sigma);
            cosSigma = Math.cos(sigma);
            double deltaSigma = B
                    * sinSigma
                    * (cos2SigmaM + B
                    / 4
                    * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B
                    / 6
                    * cos2SigmaM
                    * (-3 + 4 * sinSigma * sinSigma)
                    * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
            sigmaP = sigma;
            sigma = s / (b * A) + deltaSigma;
        }
        double tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
        double lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma
                * cosAlpha1,
                (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));
        double lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma
                - sinU1 * sinSigma * cosAlpha1);
        double C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
        double L = lambda
                - (1 - C)
                * f
                * sinAlpha
                * (sigma + C
                * sinSigma
                * (cos2SigmaM + C * cosSigma
                * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
        // var revAz = Math.atan2(sinAlpha, -tmp); // final bearing
        return new Point2D.Double(point.x + (L * 180 / Math.PI), lat2 * 180 / Math.PI);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bDraw;
    private javax.swing.JButton bDrawPoly;
    private javax.swing.JButton bGraphSel;
    private javax.swing.JLabel lCenterLat;
    private javax.swing.JLabel lCenterLon;
    private javax.swing.JLabel lCorners;
    private javax.swing.JLabel lRadius;
    private javax.swing.JLabel lUom1;
    private javax.swing.JLabel lUom2;
    private javax.swing.JLabel lUom3;
    private javax.swing.JSpinner spCenterLat;
    private javax.swing.JSpinner spCenterLon;
    private javax.swing.JSpinner spRadius;
    // End of variables declaration//GEN-END:variables

    public double getLat() {
        return (double) spCenterLat.getValue();
    }

    public double getLon() {
        return (double) spCenterLon.getValue();
    }

    public double getRadius() {
        return (double) spRadius.getValue();
    }
}
